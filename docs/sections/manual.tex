\section{Manual}
\label{sec:manual}

\subsection{Structure}
Being a scripting language, a Gryph program is nothing but a collection of statements, which are executed sequentially. The following is a valid Gryph program (the \key{println} statement is defined in \ref{}).

\begin{lstlisting}[language=Gryph]
# print hello world to standard output
println "Hello World";
\end{lstlisting}

We delineate in this section particular constructs which form the gereral structure of a Gryph program, besides regular statements such as \key{println}.

\subsubsection{Comments}
The previously listed code already demonstrates the first of such constructs in its first line: comments, text in the source code ignored by the interpreter. The beginning of a comment is marked by the \# character, and it ends on a line break. A comment does not have to begin at the beggining of a line; it can follow a valid statement, for instance. Also, since the \# character inside a comment is not even parsed by the interpreter, multiple \# characters written sequentially have no effect different from any other comment.

\subsubsection{Subprogram declarations}
\label{sec:subprogram}
Another important part of a Gryph program are subprograms, essential tools for process abstraction. To declare a subprogram, the \key{sub} keyword is used, followed by a valid identifier (see \ref{sec:idsandscope}) for that subprogram. That is followed, in turn, by a list of parameters enclosed in parentheses, the return type (if there is one), and then finally the body of the subprogram, enclosed in braces.
\begin{lstlisting}[language=Gryph]
sub hello() : string {
	return "hello";
}

sub my_print(s : string = "") {
	println s;
}
\end{lstlisting}
In the above code, we define two subprograms. The first, \id{hello}, receives no argument, and returns a ``\type{string}'' (further information on types in \ref{sec:types}). Note the \key{return} keyword in line 2, which signals the function to return the expression following it. The second, \id{my\_print}, receives `\id{s}' as an argument, a \type{string}, and returns nothing. 
The parameter list is nothing more than a sequence of variable declarations (variable declaration and attribution are described in \ref{}) separated by semicolons, the initialization syntax being used to define a default value, making the parameter optional: in \id{my\_print}, the parameter \id{s} has the empty string as its default value.

Arguments are generally passed to subprograms by copy, except if the parameter in question is marked by the ampersand character, in which case it is passed by reference. This is the only thing that differs a parameter declaration from a variable declaration, as variables cannot be marked in such way. In the following code, the function \id{add} adds to the argument passed to \id{lhs} the value of the \id{rhs} argument.
\begin{lstlisting}[language=Gryph]
sub add(lhs : int&; rhs: int) {
	lhs = lhs + rhs;
}
\end{lstlisting}

The expression used to call a subprogram consists of the subprogram identifier, followed by parentheses containing the arguments being passed to the subprogram. Such an expression can be used as a statement in itself or as part of another statement. In the following code, we call the \id{my\_print} procedure, passing the return value of the \id{hello} function as an argument.
\begin{lstlisting}[language=Gryph]
my_print(hello());
\end{lstlisting}

\subsubsection{Data type declarations}
\label{sec:typedecl}
Another part of a Gryph program, is the declaration of user-defined data types: records, more specifically. The declaration of a record starts with a type identifier, which follows rules similar to other identifiers (see \ref{sec:idsandscope}), except that it must begin with an \emph{uppercase} alphabetic character, for code clarity. 

Following the identifier, we have, enclosed in braces, a sequence of field declarations, defining the contents of a variable of that type. A field declaration is much like a variable declaration, and the initialization syntax is used in much the same way as in a subprogram parameter, as it defines a default value for a new variable of the type being defined.

In the code below, we define the type ``\type{Person}'', which contains an age (of type \type{int}), and a name (of type \type{string}). We give 0 as a default age for a new variable of the type \type{Person}. The declaration and use of variables of user-defined types is explained in \ref{sec:usertypes}.
\begin{lstlisting}[language=Gryph]
Person {
	name : string;
	age : int = 0;
}
\end{lstlisting}

\subsubsection{Identifiers and scope}
\label{sec:idsandscope}
We have mentioned, in the previous section, the concept of an identifier. An identifier is, simply, a name given to a subprogram or a variable. An identifier can be any combination of alphanumeric characters and the underscore character, as long as it starts with an alphabetic character.
% Scope
% subprograms and data types must be declared globally ?

\subsubsection{Importing files}
A Gryph program can be separated into multiple files through the use of the keyword \key{use}. It essentially indicates the insertion of source code from another file into that part of the code. For that, \key{use} must be followed by the path (relative to the interpreter) to the file one wishes to include, enclosed in quotes. Say we define the following function in a file named ``\texttt{file1.gph}'':
\begin{lstlisting}[language=Gryph]
sub f() : string {
	return "hello from file1";
}
\end{lstlisting}
We can use this function in another file as follows, considering for instance that \texttt{file1.gph} is in the same directory as the interpreter used to run the following code:
\begin{lstlisting}[language=Gryph]
use "file1.gph"

println f();
\end{lstlisting}

\subsection{Types}
\label{sec:types}
The Gryph language is statically typed, meaning the type of all variables is know at ``compile time'', before beginning the execution. Also, most variables, all subprogram parameters, and all fields in user-defined data types are explicitly typed. In this section, we discuss all possible types in the Gryph language, their use, and their form: built-in types, both primitive (\ref{sec:primitive}), and composite (\ref{sec:composite}); as well as user-defined types (\ref{sec:usertypes}).
\subsubsection{Primitive types}
\label{sec:primitive}
Pritive types in Gryph are much the same as in most other programming languages. There are two numeric types: \type{int}, which stores an integer, and \type{float}, which stores a floating-point real number. Bounds for the possible values for variables of these types are implementation-dependent, as well as the precision for \type{float} variables. Literals of these types are recognized as being a sequence of digits, and a sequence of digits containing a period, respectively.

A variable of the \type{char} type contains up to a single character, whereas one of the \type{string} type contains any number of characters, of an encoding defined by the implementation. A \type{char} literal is delimited by single quotes, and a \type{string} by double quotes. 

Last but not least, is the type \type{bool}, which represents a boolean value: \key{true} or \key{false}. In the following code, we declare and initialize a variable of each of the primitive types.
\begin{lstlisting}[language=Gryph]
i : int = -9;
f : float = 0.1;
c : char = '$';
s : string = "hwyl";
b : bool = true;
\end{lstlisting}

\subsubsection{Composite types}
\label{sec:composite}
Composite types are built-in types of the Gryph language which are composed of other types. As we will see, each composite type has its own characterizing delimiter, used to write variables of that type and to access them.

The first and most simple of these is a \type{tuple}, delimited by parentheses. It consists of a fixed sequence of immutable values of different types, separated by commas, enclosed in parentheses. The syntax for accessing a particular (0-indexed) position in a tuple is an exception in that it does not use the type delimiter (parentheses, in this case), but the backslash.

We also have the \type{list}, a list of mutable values, all of the same type, delimited by square brackets, which are also used to access a particular (again, 0-indexed) position in the list. Lists can grow and shrink in size in execution time, as elements are appended to or removed from them.

The \type{dictionary} or \type{map} is used for associating ``keys'' of a certain type to ``value'' of another (or the same) type. It can also grow and shrink dynamically. It consists of comma-separated key/value pairs seperated by a question mark, and is delimited by the pipe (or vertical bar), which is also used to access the value associated with a particular key.

% graphs

In the code below, we declare and initialize variables of each of these types, and access values contained in them, the printed values being indicated by an accompanying comment. Statements for insertion and removal of elements from certain composite types is covered in \ref{} and operations (besides access) with them in \ref{}.
\begin{lstlisting}[language=Gryph]
t : (int, char, int) = (-1, 'x', 1);
println t\1\; # 'x'

l : [int] = [-2, 0, 1];
l[1] = l[0] + 1;
println l[1]; # -1

d : |char, int| = |'a' ? 1, 'c' ? 3|;
d|'a'| = 0;
println d|'a'|; # 0


\end{lstlisting}
\subsubsection{User-defined types}
\label{sec:usertypes}
A user-defined type, or \type{record}, must firstly be declared, as described in \ref{sec:typedecl}, before any variable of that type can be declared. A variable of a user-defined type is declared as one of any other type, and an expression of a user-defined type consists of that type's identifier, followed by a list of comma-separated attributions for any of that type's fields, delimited by braces. Braces are also used to access a particular field in a \type{record} variable, as demonstrated in the following code:
\newcounter{AgeofEuler}
\setcounter{AgeofEuler}{\year-1707}
\begin{lstlisting}[language=Gryph,escapeinside={(*}{*)}]
Person {
	name : string;
	age : int = 0;
}

p : Person = Person {name = "Leonhard"};
p{age} = (*\theAgeofEuler*);
println p{name}; # "Leonhard"
println p{age}; # (*\gryphcommentstyle\theAgeofEuler*)
\end{lstlisting}

\subsection{Expressions}
pass

\subsection{Statements}
pass