\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{backnaur}
\usepackage[margin=2cm]{geometry}

\title{BNF for the Gryph Programming Language}
\author{Vitor Greati \and Artur Curinga \and Carlos Vieira \and Vin√≠cius Campos}

\begin{document}

\maketitle

\tableofcontents

\section{General structure}


    \subsection{Program}
    \begin{bnf*}
        \bnfprod{program}{\bnfpn{program-unit} \bnfor \bnfpn{program-unit}\bnfpn{program}}\\
        \bnfprod{program-unit}{\bnfpn{stmt} \bnfsp \bnfts{;} \bnfor \bnfpn{subprog-decl}}
    \end{bnf*}

    \subsection{Statements}
    \begin{bnf*}
        \bnfprod{stmt-list}{\bnfpn{stmt} \bnfsp \bnfts{;} \bnfor \bnfpn{stmt}\bnfsp\bnfts{;}\bnfsp\bnfpn{stmt-list}}\\
        \bnfprod{stmt-block}{\bnfts{\{} \bnfsp \bnfpn{stmt-list} \bnfsp \bnfts{\}}}\\
        \bnfprod{block-or-matched}{\bnfpn{stmt-block} \bnfor \bnfpn{matched-stmt}\bnfts{;}}\\
        \bnfprod{com-stmt}{\bnfpn{read-stmt} \bnfor \bnfpn{print-stmt} \bnfor \bnfpn{var-decl-stmt}}\\
        \bnfprod{stmt}{\bnfpn{matched-stmt} \bnfor \bnfpn{unmatched-stmt}}\\
        \bnfprod{matched-stmt}{\bnfpn{matched-if-else} \bnfor \bnfpn{com-stmt}}\\
        \bnfprod{unmatched-stmt}{\bnfpn{if-stmt} \bnfor \bnfpn{unmatched-if-else}}\\
    \end{bnf*}

        \subsubsection{IO}
        \begin{bnf*}
            \bnfprod{read-stmt}{\bnfts{read} \bnfsp \bnfpn{ident}}\\
            \bnfprod{write-stmt}{\bnfts{print} \bnfsp \bnfpn{ident} \bnfor \bnfts{print} \bnfsp \bnfpn{string-lit}}\\
        \end{bnf*}

        \subsubsection{Variables}
        \begin{bnf*}
            \bnfprod{ident-begin-stmt}{\bnfpn{ident-list}\bnfpn{ident-list-post}}\\
            \bnfprod{ident-list-post}{ \bnfts{:} \bnfpn{type} \bnfpn{var-decl-stmt} \bnfor \bnfpn{var-attr-stmt}}\\
            \bnfprod{var-decl-stmt}{\bnfes \bnfor \bnfpn{var-attr-stmt}}\\
            \bnfprod{var-attr-stmt}{\bnfts{=} \bnfpn{expr-list}}\\
        \end{bnf*}

    \subsection{Subprograms}
        \subsubsection{Declaration}
        \subsubsection{Call}
            \begin{bnf*}
                \bnfprod{subprog-call}{\bnfpn{ident}\bnfts{(}\bnfpn{expr-list}\bnfts{)}}
            \end{bnf*}

\section{Control Structures}
    \subsection{If-else statements}
        \begin{bnf*}
        \bnfprod{if-expr}{\bnfts{if} \bnfsp \bnfts{(}\bnfpn{b-exp}\bnfts{)}}\\
        \bnfprod{if-stmt}{\bnfpn{if-expr} \bnfsp \bnfpn{stmt}\bnfts{;}}\\
        \bnfprod{unmatched-if-else}{\bnfpn{if-expr} \bnfsp \bnfpn{matched-stmt}\bnfts{;} \bnfsp \bnfts{else} \bnfsp \bnfpn{unmatched-stmt}\bnfts{;}}\\
        \bnfprod{matched-if-else}{\bnfpn{if-expr} \bnfsp \bnfpn{block-or-matched} \bnfsp \bnfts{else} \bnfsp \bnfpn{block-or-matched} \bnfor \bnfpn{if-expr} \bnfsp \bnfpn{stmt-block}}\\
        \end{bnf*}

\section{Types}
    \begin{bnf*}
        \bnfprod{type-list}{\bnfpn{type}\bnfts{,}\bnfpn{type-list} \bnfor \bnfpn{type}}\\
        \bnfprod{type}{\bnfpn{native-type} \bnfor \bnfpn{user-type}}\\
        \bnfprod{native-type}{\bnfpn{primitive-type} \bnfor \bnfpn{composite-type}}\\
        \bnfprod{primitive-type}{\bnfts{int} \bnfor \bnfts{float} \bnfor \bnfts{char} \bnfor \bnfts{string}}\\
        \bnfprod{composite-type}{\bnfts{[} \bnfpn{type} \bnfts{]} \bnfor \bnfts{$\mid$} \bnfpn{type} \bnfts{$\mid$} 
        \bnfor \bnfts{(} \bnfpn{type} \bnfts{,} \bnfpn{type-list} \bnfts{)} \bnfor \bnfpn{graph-type}}\\
        \bnfprod{graph-type}{\bnfts{$<$} \bnfpn{type} \bnfts{$>$} \bnfor \bnfts{$<$} \bnfpn{type} \bnfts{,} \bnfpn{type} \bnfts{$>$}}\\
        \bnfprod{user-type}{\bnfpn{upper-letter}\bnfpn{alpha-num-list}}\\
    \end{bnf*}

    \paragraph{Observations}
    \begin{itemize}
        \item The maximum size of tuples depends on the language implementation, though, in the BNF description
            above, it may assume any value.
    \end{itemize}

\section{Expressions}

    \subsection{Any expression}
        {\scriptsize
        \begin{bnf*}
            \bnfprod{expression}{\bnfpn{logical-xor-expr}}\\
            \bnfprod{logical-xor-expr}{\bnfpn{logical-or-expr} \bnfor \bnfpn{logical-or-expr}\bnfpn{logical-xor-expr-aux}}\\
            \bnfprod{logical-xor-expr-aux}{\bnfts{xor}\bnfsp\bnfpn{logical-or-expr}\bnfor \bnfts{xor}\bnfsp\bnfpn{logical-or-expr}\bnfpn{logical-xor-expr-aux}}\\
            \bnfprod{logical-or-expr}{\bnfpn{logical-and-expr} \bnfor \bnfpn{logical-and-expr}\bnfpn{logical-or-expr-aux}}\\
            \bnfprod{logical-or-expr-aux}{\bnfts{or}\bnfsp\bnfpn{logical-and-expr}\bnfor \bnfts{or}\bnfsp\bnfpn{logical-and-expr}\bnfpn{logical-or-expr-aux}}\\
            \bnfprod{logical-and-expr}{\bnfpn{equality-expr} \bnfor \bnfpn{equality-expr}\bnfpn{logical-and-expr-aux}}\\
            \bnfprod{logical-and-expr-aux}{\bnfts{and}\bnfsp\bnfpn{equality-expr}\bnfor \bnfts{and}\bnfsp\bnfpn{equality-expr}\bnfpn{logical-and-expr-aux}}\\
            \bnfprod{equality-expr}{\bnfpn{rel-expr} \bnfor \bnfpn{rel-expr}\bnfpn{rel-expr-aux}}\\
            \bnfprod{equality-expr-aux}{\bnfpn{equality-op}\bnfsp\bnfpn{rel-expr}\bnfor \bnfpn{equality-op}\bnfsp\bnfpn{rel-expr}\bnfpn{equality-expr-aux}}\\
            \bnfprod{rel-expr}{\bnfpn{add-expr}\bnfpn{rel-expr-aux}}\\
            \bnfprod{rel-expr-aux}{ \bnfpn{rel-op}\bnfpn{add-expr} \bnfor \bnfpn{rel-op}\bnfpn{add-expr}\bnfpn{rel-expr-aux}}\\
            \bnfprod{add-expr}{\bnfpn{mult-expr} \bnfor \bnfpn{mult-expr}\bnfpn{add-expr-aux}}\\
            \bnfprod{add-expr-aux}{\bnfpn{add-op}\bnfpn{mult-expr} \bnfor \bnfpn{add-op}\bnfpn{mult-expr}\bnfpn{add-expr-aux}}\\
            \bnfprod{mult-expr}{\bnfpn{exp-expr} \bnfor \bnfpn{exp-expr}\bnfpn{mult-expr-aux}}\\
            \bnfprod{mult-expr-aux}{\bnfpn{mult-op}\bnfpn{exp-expr} \bnfor \bnfpn{mult-op}\bnfpn{exp-expr}\bnfpn{mult-expr-aux}}\\
            \bnfprod{exp-expr}{\bnfpn{cast-expr} \bnfor \bnfpn{cast-expr}\bnfpn{exp-op}\bnfpn{exp-expr}}\\
            %\bnfprod{exp-expr}{\bnfpn{cast-expr} \bnfor \bnfpn{cast-expr}\bnfpn{exp-expr-aux}}\\
            %\bnfprod{exp-expr-aux}{\bnfpn{exp-op}\bnfpn{cast-expr} \bnfor \bnfpn{exp-op}\bnfpn{cast-expr}\bnfpn{exp-expr-aux}}\\
            \bnfprod{cast-expr}{\bnfpn{unary-expr} \bnfor \bnfpn{unary-expr}\bnfpn{cast-expr-aux}}\\
            \bnfprod{cast-expr-aux}{\bnfts{@}\bnfpn{type} \bnfor \bnfts{@}\bnfpn{type}\bnfpn{cast-expr-aux}}\\
            \bnfprod{unary-expr}{\bnfpn{unary-op}\bnfpn{cast-expr} \bnfor \bnfpn{postfix-expr}}\\
            \bnfprod{postfix-expr}{\bnfpn{primary-expr} \bnfor \bnfpn{ident}\bnfts{$|$}\bnfts{expression}\bnfts{$|$} \bnfor 
            \bnfpn{ident}\bnfts{$<$}\bnfts{expression}\bnfts{$>$} \bnfor
            \bnfpn{ident}\bnfts{$[$}\bnfts{expression}\bnfts{$]$} \bnfor
            \bnfpn{ident}\bnfts{$\{$}\bnfpn{ident}\bnfts{$\}$} \bnfor
            \bnfpn{ident}\bnfts{.}\bnfpn{expression}
            }\\
            \bnfprod{primary-expr}{\bnfts{(}\bnfpn{expression}\bnfts{)} \bnfor \bnfpn{ident} \bnfor \bnfpn{subprogcall} \bnfor \bnfpn{constant} }\\
            \bnfprod{constant}{\bnfpn{int-lit} \bnfor \bnfpn{float-lit} \bnfor \bnfpn{string-lit} \bnfor \bnfpn{bool-lit}} \bnfor \bnfpn{list-lit} \bnfor \bnfpn{graph-lit}\\
            \bnfprod{rel-op}{\bnfts{$>$} \bnfor \bnfts{$<$} \bnfor \bnfts{$<=$} \bnfor \bnfts{$>=$}}\\
            \bnfprod{equality-op}{\bnfts{==} \bnfor \bnfts{!=}}\\
            \bnfprod{unary-op}{\bnfts{+} \bnfor \bnfts{-}}\\
            \bnfprod{add-op}{\bnfts{+} \bnfor \bnfts{-}}\\
            \bnfprod{mult-op}{\bnfts{*} \bnfor \bnfts{/} \bnfor \bnfts{\%} \bnfor \bnfts{++} \bnfor \bnfts{**}}\\
            \bnfprod{exp-op}{\bnfts{\^}}\\
        \end{bnf*}}

    \subsection{Relational expressions}
        \begin{bnf*}
            \bnfprod{rel-expr}{\bnfpn{rel-term}\bnfpn{rel-expr-aux}}\\
            \bnfprod{rel-expr-aux}{ \bnfpn{rel-op}\bnfpn{rel-term} \bnfor \bnfpn{rel-op}\bnfpn{rel-term}\bnfpn{rel-expr-aux}}\\
            \bnfprod{rel-op}{\bnfts{$>$} \bnfor \bnfts{$<$} \bnfor \bnfts{$<=$} \bnfor \bnfts{$>=$} \bnfor \bnfts{$==$} \bnfor \bnfts{$!=$}}\\
            \bnfprod{rel-term}{\bnfts{(}\bnfpn{rel-expr}\bnfts{)} \bnfor \bnfpn{bool-expr} \bnfor \bnfpn{expr}}\\
        \end{bnf*}

    \subsection{Boolean expressions}
        \begin{bnf*}
            \bnfprod{b-expr}{\bnfpn{b-term} \bnfor \bnfpn{b-term}\bnfpn{b-expr-aux}}\\
            \bnfprod{b-expr-aux}{\bnfpn{b-bin-op-p0}\bnfpn{b-term} \bnfor \bnfpn{b-bin-op-p0}\bnfpn{b-term}\bnfpn{b-expr-aux}}\\
            \bnfprod{b-term}{\bnfpn{b-literal} \bnfor \bnfpn{b-literal} \bnfpn{b-term-aux}}\\
            \bnfprod{b-term-aux}{\bnfpn{b-bin-op-p1}\bnfpn{b-literal} \bnfor \bnfpn{b-bin-op-p1}\bnfpn{b-literal}\bnfpn{b-term-aux}}\\
            \bnfprod{b-literal}{\bnfpn{b-base} \bnfor \bnfpn{b-un-op}\bnfpn{b-base}}\\
            \bnfprod{b-base}{\bnfts{(} \bnfsp \bnfpn{b-expr} \bnfsp \bnfts{)} \bnfor \bnfts{true} \bnfor \bnfts{false} \bnfor \bnfpn{rel-expr}
                        \bnfor \bnfpn{ident} \bnfor \bnfpn{subprog-call}}\\
            \bnfprod{b-un-op}{\bnfts{not}}\\
            \bnfprod{b-bin-op-p0}{\bnfts{or} \bnfor \bnfts{xor}}\\
            \bnfprod{b-bin-op-p1}{\bnfts{and}}\\
        \end{bnf*}

    \subsection{Expressions with numbers, lists and strings}

    \begin{bnf*}
        \bnfprod{expr}{\bnfpn{term} \bnfor \bnfpn{term}\bnfpn{expr-aux}}\\
        \bnfprod{expr-aux}{\bnfpn{bin-op-p0}\bnfpn{term} \bnfor \bnfpn{bin-op-p0}\bnfpn{term}\bnfpn{expr-aux}}\\
        \bnfprod{term}{\bnfpn{factor} \bnfor \bnfpn{factor} \bnfpn{term-aux}}\\
        \bnfprod{term-aux}{\bnfpn{bin-op-p1}\bnfpn{factor} \bnfor \bnfpn{bin-op-p1}\bnfpn{factor}\bnfpn{term-aux}}\\
        \bnfprod{factor}{\bnfpn{literal} \bnfts{\^} \bnfpn{factor} \bnfor \bnfpn{literal}}\\
        \bnfprod{literal}{\bnfpn{basis} \bnfor \bnfts{+}\bnfpn{basis} \bnfor \bnfts{-}\bnfpn{basis}}\\
        \bnfprod{basis}{\bnfts{(} \bnfsp \bnfpn{expr} \bnfsp \bnfts{)} \bnfor \bnfpn{ident} \bnfor \bnfpn{int-lit} \bnfor \bnfpn{float-lit}
                \bnfor \bnfpn{list-lit} \bnfor \bnfpn{subprog-call} \bnfor \bnfpn{string-lit}}\\
        \bnfprod{un-op}{\bnfts{+} \bnfor \bnfts{-}}\\
        \bnfprod{bin-op-p0}{\bnfts{+} \bnfor \bnfts{-}}\\
        \bnfprod{bin-op-p1}{\bnfts{*} \bnfor \bnfts{/} \bnfor \bnfts{\%} \bnfor \bnfts{++} \bnfor \bnfts{**}}\\
    \end{bnf*}


\end{document}
