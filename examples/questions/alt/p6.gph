left : char = 'l';
right : char = 'r';

Node {
	value : int;
	child : |char, bool| =
		|left ? false, right ? false|;
}

BST {
	root : Node;
	tree : <Node> = <[]>;
}

sub insert(t : BST&; new_value : int) {
	if (t{tree} == <[]>) {
		t{root} = Node{value=new_value};
		add t{root} in t{tree};
		return;
	}

	curr : Node = t{root};
	while(true) {
		side : char;
		if (new_value < curr{value})
			side = left;
		else
			side = right;
		side_child : [Node] = [n for n over t{tree}<curr> when (n{child}|side|)];
		if (side_child == []) {
			new : Node = Node{value=new_value};
			new{child}|side| = true;
			add new in t{tree};
			add curr->new in t{tree};
			break;
		} else {
			curr = side_child[0];
		}
	}
}



sub print_inorder(t : BST&) {
	stack : [Node] = [];
	top : int = -1;
	curr : [Node] = [t{root}];

	while (true) {
		if (curr != []) {
			add curr[0] in stack;
			top = top + 1;
			curr = [n for n over t{tree}<curr[0]> when (n{child}|left|)];
		} else {
			if (top >= 0) {
				pop : Node = stack[top];
				del top from stack;
				top = top - 1;

				print pop{value}@string+" ";
				curr = [n for n over t{tree}<pop> when (n{child}|right|)];
			} else {
				println "";
				break;
			}
		}
	}
}

sub print_levels(t : BST&) {
	newline : Node = Node{child=|left?true, right?true|};
	queue : [Node] = [t{root}, newline];

	while(queue != []) {
		dq : Node = queue[0];
		del 0 from queue;

		if (dq == newline) {
			println "";
			if (queue != [])
				add newline in queue;
		} else {
			print dq{value}@string+" ";
			l : [Node] = [n for n over t{tree}<dq> when (n{child}|left|)];
			r : [Node] = [n for n over t{tree}<dq> when (n{child}|right|)];
			for n over [l, r] {
				if (n != [])
					add n[0] in queue;
			}
		}
	}
}

sub side_most(t : BST&; side : char) : int {
	last : Node;
	curr : [Node] = [t{root}];
	while (curr != []) {
		last = curr[0];
		curr = [n for n over t{tree}<last> when (n{child}|side|)];
	}
	return last{value};
}

sub min(t : BST&) : int {
	return side_most(t, left);
}

sub max(t : BST&) : int {
	return side_most(t, right);
}

t1 : BST;

insert(t1, 0);
insert(t1, -10);
insert(t1, 6);
insert(t1, -20);
insert(t1, 5);

println "inorder traversal: ";
print_inorder(t1);

println "breadth first traversal: ";
print_levels(t1);

println "min: "+min(t1)@string;
println "max: "+max(t1)@string;